# YubiKey OTP Authentication Package

The `yubikey` package provides authentication using YubiKey hardware tokens via One-Time Passwords (OTP). It validates YubiKey-generated OTPs against Yubico's validation service or compatible servers.

## Overview

YubiKey OTP authentication validates one-time passwords generated by YubiKey hardware tokens. This provides strong two-factor authentication with:

- **Hardware token**: Something you have (YubiKey device)
- **OTP generation**: Cryptographic proof of possession
- **Cloud validation**: Yubico validation service or self-hosted servers
- **Replay protection**: Each OTP is valid for single use only

YubiKey OTP is commonly used for:
- Two-factor authentication (2FA)
- Multi-factor authentication (MFA)
- Hardware token authentication
- Privileged access management

## Architecture

The module uses an interface-based design for testability:

```
┌─────────────────┐
│  Authenticator  │
└────────┬────────┘
         │
         ▼
  ┌──────────────┐      ┌──────────────┐
  │    Config    │      │ OTPValidator │
  └──────────────┘      └──────┬───────┘
                               │
                               ▼
                        ┌──────────────┐
                        │  Validation  │
                        │   Service    │
                        └──────────────┘
```

### Components

- **Config**: Client ID and API key for validation service
- **OTPValidator**: Interface for validating OTPs (enables testing)
- **Authenticator**: Main authentication orchestrator
- **Validation Service**: Yubico cloud or self-hosted validator

## Features

- YubiKey OTP validation
- Yubico cloud service support
- Self-hosted validation server support
- Interface-based design for testing
- Context-aware operation
- Thread-safe concurrent usage
- Automatic replay protection

## Quick Start

### Basic Authentication

```go
package main

import (
    "context"
    "log"

    "github.com/jhahn/go-auth/pkg/yubikey"
)

func main() {
    // Configure YubiKey authentication
    cfg := yubikey.Config{
        ClientID: "12345",
        APIKey:   "base64-encoded-api-key",
    }

    // Create authenticator (requires validator implementation)
    validator := NewYubiCloudValidator() // Implementation not shown
    auth, err := yubikey.NewAuthenticator(cfg, validator)
    if err != nil {
        log.Fatal(err)
    }

    // Authenticate with YubiKey OTP
    // User touches YubiKey which outputs OTP to keyboard
    ctx := context.Background()
    otp := "ccccccbcgujhingjrdejhgfnuetrgigvejhhgbkugded"

    err = auth.Authenticate(ctx, otp)
    if err == yubikey.ErrInvalidOTP {
        log.Println("Invalid or replayed OTP")
        return
    }
    if err != nil {
        log.Printf("Error: %v", err)
        return
    }

    log.Println("Authentication successful")
}
```

### With System Validator

Set a default validator for all authenticators:

```go
// In application initialization
validator := NewYubiCloudValidator()
yubikey.SetSystemValidator(validator)

// Later, create authenticators without explicit validator
cfg := yubikey.Config{
    ClientID: "12345",
    APIKey:   "base64-api-key",
}

auth, err := yubikey.NewAuthenticator(cfg, nil)
```

## Configuration

### Config Structure

```go
type Config struct {
    ClientID string  // Yubico client ID
    APIKey   string  // Yubico API key (base64-encoded)
}
```

### Obtaining Credentials

1. **Get Yubico API credentials** (for cloud validation):
   - Visit https://upgrade.yubico.com/getapikey/
   - Enter email and YubiKey OTP
   - Receive Client ID and Secret Key

2. **Configure self-hosted server**:
   - Install ykval (YubiKey Validation Server)
   - Generate client ID and API key
   - Use custom validator implementation

### Configuration Validation

```go
// Valid configuration
cfg := yubikey.Config{
    ClientID: "12345",
    APIKey:   "YourBase64EncodedAPIKey==",
}

auth, err := yubikey.NewAuthenticator(cfg, validator)
```

### Configuration Errors

```go
// Empty client ID
cfg := yubikey.Config{APIKey: "key"}
auth, err := yubikey.NewAuthenticator(cfg, nil)
// Error: "yubikey: client id must not be empty"

// Empty API key
cfg := yubikey.Config{ClientID: "12345"}
auth, err := yubikey.NewAuthenticator(cfg, nil)
// Error: "yubikey: api key must not be empty"

// No validator
auth, err := yubikey.NewAuthenticator(cfg, nil)
// Error: "yubikey: system validator unavailable"
```

## OTP Format

YubiKey OTPs are 44-character strings:

```
ccccccbcgujhingjrdejhgfnuetrgigvejhhgbkugded
└─────┘└────────────────────────────────────┘
  12      32 characters
 chars    (encrypted OTP)
 (ID)
```

- **First 12 characters**: Public ID (identifies the YubiKey)
- **Last 32 characters**: Encrypted OTP (counter, timestamp, session)

## Authentication Flow

1. **User interaction**: User touches YubiKey, OTP typed into field
2. **Extract OTP**: Application captures 44-character OTP
3. **Validate OTP**: Send to validation service with client credentials
4. **Verify response**: Check signature and status
5. **Return result**: Success or failure

## Error Handling

```go
err := auth.Authenticate(ctx, otp)

switch {
case err == nil:
    // Success
    log.Println("YubiKey authenticated")

case errors.Is(err, yubikey.ErrInvalidOTP):
    // OTP invalid, replayed, or validation failed
    log.Println("Invalid OTP - may be replayed or malformed")

case errors.Is(err, context.Canceled):
    // Context cancelled
    log.Println("Operation cancelled")

case errors.Is(err, context.DeadlineExceeded):
    // Timeout
    log.Println("Validation service timed out")

default:
    // Other errors (network, service unavailable, etc.)
    log.Printf("Error: %v", err)
}
```

### OTP Validation Errors

```go
// Empty OTP
err := auth.Authenticate(ctx, "")
// Error: "yubikey: otp must not be empty"

// Invalid OTP format (too short/long)
err := auth.Authenticate(ctx, "invalid")
// Depends on validator implementation

// Replayed OTP
err := auth.Authenticate(ctx, "previously-used-otp")
// Error: yubikey.ErrInvalidOTP
```

## OTPValidator Interface

Implement this interface for custom validation:

```go
type OTPValidator interface {
    Validate(ctx context.Context, clientID, secret, otp string) error
}
```

### Yubico Cloud Validator Example

```go
import (
    "context"
    "crypto/hmac"
    "crypto/sha1"
    "encoding/base64"
    "fmt"
    "net/http"
    "net/url"
)

type YubiCloudValidator struct {
    apiURL string
    client *http.Client
}

func NewYubiCloudValidator() *YubiCloudValidator {
    return &YubiCloudValidator{
        apiURL: "https://api.yubico.com/wsapi/2.0/verify",
        client: &http.Client{Timeout: 10 * time.Second},
    }
}

func (v *YubiCloudValidator) Validate(ctx context.Context, clientID, apiKey, otp string) error {
    // Build request
    nonce := generateNonce() // Random nonce for replay protection

    params := url.Values{}
    params.Set("id", clientID)
    params.Set("otp", otp)
    params.Set("nonce", nonce)

    // Generate HMAC signature
    signature := generateSignature(params, apiKey)
    params.Set("h", signature)

    // Make request
    reqURL := fmt.Sprintf("%s?%s", v.apiURL, params.Encode())
    req, _ := http.NewRequestWithContext(ctx, "GET", reqURL, nil)

    resp, err := v.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    // Parse and verify response
    result := parseResponse(resp.Body)
    if result.Status != "OK" {
        return yubikey.ErrInvalidOTP
    }

    // Verify response signature
    if !verifyResponseSignature(result, apiKey) {
        return errors.New("invalid response signature")
    }

    return nil
}
```

### Mock Validator for Testing

```go
type MockValidator struct {
    err error
}

func (m *MockValidator) Validate(ctx context.Context, clientID, secret, otp string) error {
    return m.err
}

// Use in tests
func TestAuthentication(t *testing.T) {
    mockValidator := &MockValidator{}

    cfg := yubikey.Config{
        ClientID: "test",
        APIKey:   "test-key",
    }

    auth, err := yubikey.NewAuthenticator(cfg, mockValidator)
    if err != nil {
        t.Fatal(err)
    }

    err = auth.Authenticate(context.Background(), "test-otp")
    // ... assertions
}
```

## Context Management

### With Timeout

```go
import "time"

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

err := auth.Authenticate(ctx, otp)
if err == context.DeadlineExceeded {
    log.Println("Validation service did not respond in time")
}
```

### With Cancellation

```go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

go func() {
    <-sigChan
    cancel() // Cancel on signal
}()

err := auth.Authenticate(ctx, otp)
```

## Integration with go-auth API

```go
import (
    "github.com/jhahn/go-auth/pkg/api"
    "github.com/jhahn/go-auth/pkg/yubikey"
)

validator := NewYubiCloudValidator()
cfg := yubikey.Config{
    ClientID: "12345",
    APIKey:   "base64-api-key",
}

yubikeyAuth, _ := yubikey.NewAuthenticator(cfg, validator)

service, _ := api.NewService(api.Config{
    Backends: []api.Backend{
        {Name: api.BackendYubiKey, Handler: api.YubiKey(yubikeyAuth)},
    },
})

// Authenticate (OTP passed as password)
err := service.Login(ctx, api.LoginRequest{
    Backend:  api.BackendYubiKey,
    Password: "ccccccbcgujhingjrdejhgfnuetrgigvejhhgbkugded",
})
```

## Security Considerations

### OTP Replay Protection

YubiKey OTPs include:
- **Counter**: Increments with each use
- **Timestamp**: Time of OTP generation
- **Session ID**: Random session identifier

Validation service ensures:
- OTP has never been used before
- Counter is greater than previous
- OTP is not too old (prevents replay)

### API Key Security

1. **Secure storage** - Never commit API keys to version control
2. **Environment variables** - Load from environment
   ```go
   apiKey := os.Getenv("YUBIKEY_API_KEY")
   ```
3. **Secret managers** - Use AWS Secrets Manager, HashiCorp Vault, etc.
4. **Key rotation** - Regenerate keys periodically
5. **Access control** - Limit who can access keys

### Transport Security

Yubico API uses HTTPS:
- All communications encrypted
- Prevents OTP interception
- Protects API credentials

For self-hosted validators:
- Always use HTTPS
- Verify TLS certificates
- Use strong cipher suites

### Best Practices

1. **User binding** - Associate YubiKey public ID with user account
2. **Rate limiting** - Prevent brute force attacks
3. **Audit logging** - Log all authentication attempts
4. **Timeout configuration** - Prevent indefinite waits
5. **Fallback mechanisms** - Alternative auth if YubiKey unavailable
6. **User enrollment** - Verify YubiKey ownership during registration

### YubiKey Binding

Associate YubiKey public ID with user accounts:

```go
// Extract public ID from OTP
func extractPublicID(otp string) string {
    if len(otp) >= 12 {
        return otp[:12]
    }
    return ""
}

// During user enrollment
publicID := extractPublicID(otp)
// Store publicID with user account

// During authentication
submittedPublicID := extractPublicID(otp)
if submittedPublicID != user.YubiKeyID {
    return errors.New("YubiKey does not belong to this user")
}
```

## Advanced Usage

### Multiple YubiKeys per User

Support multiple YubiKeys for redundancy:

```go
type User struct {
    Username      string
    YubiKeyIDs    []string  // Multiple YubiKey public IDs
}

func (u *User) HasYubiKey(otp string) bool {
    publicID := extractPublicID(otp)
    for _, id := range u.YubiKeyIDs {
        if id == publicID {
            return true
        }
    }
    return false
}

// During authentication
if !user.HasYubiKey(otp) {
    return errors.New("unrecognized YubiKey")
}

err := auth.Authenticate(ctx, otp)
```

### Self-Hosted Validation Server

Implement custom validator for self-hosted server:

```go
type SelfHostedValidator struct {
    serverURL string
    client    *http.Client
}

func NewSelfHostedValidator(serverURL string) *SelfHostedValidator {
    return &SelfHostedValidator{
        serverURL: serverURL,
        client:    &http.Client{Timeout: 10 * time.Second},
    }
}

func (v *SelfHostedValidator) Validate(ctx context.Context, clientID, apiKey, otp string) error {
    // Custom validation logic for your server
    // Similar to YubiCloudValidator but with your API format
    return nil
}

// Use self-hosted validator
validator := NewSelfHostedValidator("https://yubikey.company.com/verify")
auth, _ := yubikey.NewAuthenticator(cfg, validator)
```

### Combined Authentication

Combine YubiKey with username/password:

```go
func authenticateUser(ctx context.Context, username, password, otp string) error {
    // First, validate username/password
    user, err := validatePassword(username, password)
    if err != nil {
        return err
    }

    // Then, validate YubiKey
    if !user.HasYubiKey(otp) {
        return errors.New("YubiKey not registered to user")
    }

    err = yubikeyAuth.Authenticate(ctx, otp)
    if err != nil {
        return fmt.Errorf("YubiKey validation failed: %w", err)
    }

    return nil
}
```

### Concurrent Authentication

Authenticators are thread-safe:

```go
auth, _ := yubikey.NewAuthenticator(cfg, validator)

// Safe to use from multiple goroutines
var wg sync.WaitGroup
for _, otp := range otps {
    wg.Add(1)
    go func(o string) {
        defer wg.Done()
        err := auth.Authenticate(ctx, o)
        // ... handle result
    }(otp)
}
wg.Wait()
```

## Performance

### Benchmark Results

Typical authentication latency:
- Yubico cloud: 100-500ms (depends on location)
- Self-hosted (local network): 20-100ms
- Self-hosted (same datacenter): 10-50ms

Performance factors:
- Network latency to validation service
- Validation service load
- API key verification overhead
- Database lookup (for self-hosted)

### Optimization

- **Caching** - Don't cache OTPs (security risk)
- **Timeout tuning** - Balance responsiveness vs reliability
- **Self-hosting** - Reduce latency with local validators
- **Connection pooling** - Reuse HTTP connections
- **Async validation** - Don't block critical paths

## Troubleshooting

### Invalid OTP Format

```
Error: invalid OTP format
```

Causes:
- OTP too short or too long
- Non-ModHex characters (valid: cbdefghijklnrtuv)
- Corrupted input

Solutions:
1. Verify OTP is 44 characters
2. Check for input field issues (autocomplete, etc.)
3. Validate characters are ModHex
4. Have user regenerate OTP

### Replayed OTP

```
Error: yubikey: invalid OTP
```

Causes:
- OTP already used
- User submitted same OTP twice
- Man-in-the-middle replay attack

Solutions:
1. Have user generate new OTP
2. Educate users not to reuse OTPs
3. Check for MITM attacks
4. Verify validation service security

### Validation Service Timeout

```
Error: context deadline exceeded
```

Causes:
- Slow network to validation service
- Service overloaded or down
- Firewall blocking outbound HTTPS

Solutions:
1. Increase timeout:
   ```go
   ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
   ```
2. Check network connectivity
3. Verify firewall rules (allow HTTPS to api.yubico.com)
4. Consider self-hosted validator

### Signature Verification Failed

```
Error: invalid response signature
```

Causes:
- Incorrect API key
- Response tampering
- API key encoding issue

Solutions:
1. Verify API key is correct
2. Check base64 encoding
3. Regenerate API credentials
4. Verify HTTPS connection

### YubiKey Not Recognized

```
Error: YubiKey not registered to user
```

Causes:
- Public ID mismatch
- User using different YubiKey
- Public ID not stored correctly

Solutions:
1. Verify public ID extraction
2. Check user enrollment process
3. Allow user to register new YubiKey
4. Support multiple YubiKeys per user

## Testing

### Mock Validator

```go
func TestYubiKeyAuthentication(t *testing.T) {
    tests := []struct {
        name      string
        otp       string
        mockErr   error
        expectErr bool
    }{
        {
            name:      "valid OTP",
            otp:       "ccccccbcgujhingjrdejhgfnuetrgigvejhhgbkugded",
            mockErr:   nil,
            expectErr: false,
        },
        {
            name:      "invalid OTP",
            otp:       "ccccccbcgujhingjrdejhgfnuetrgigvejhhgbkugded",
            mockErr:   yubikey.ErrInvalidOTP,
            expectErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockValidator := &MockValidator{err: tt.mockErr}
            cfg := yubikey.Config{
                ClientID: "test",
                APIKey:   "test-key",
            }

            auth, err := yubikey.NewAuthenticator(cfg, mockValidator)
            if err != nil {
                t.Fatal(err)
            }

            err = auth.Authenticate(context.Background(), tt.otp)
            if (err != nil) != tt.expectErr {
                t.Errorf("expected error: %v, got: %v", tt.expectErr, err)
            }
        })
    }
}
```

## YubiKey Hardware

### YubiKey Models

All YubiKey models support OTP:
- **YubiKey 5 Series** - USB-A, USB-C, NFC, Nano
- **YubiKey 4 Series** - Legacy (still supported)
- **Security Key Series** - FIDO-only (no OTP)
- **YubiKey NEO** - Legacy NFC support

### Programming YubiKeys

YubiKeys come pre-programmed with OTP, but can be reprogrammed:

```bash
# Install YubiKey Manager
sudo apt-get install yubikey-manager

# Program OTP slot
ykman otp yubiotp 1 --serial-public-id --generate
```

### Slot Configuration

YubiKeys have two OTP slots:
- **Slot 1**: Short press (default Yubico OTP)
- **Slot 2**: Long press (configurable)

## References

- [YubiKey OTP Documentation](https://developers.yubico.com/OTP/)
- [Yubico Validation Protocol](https://developers.yubico.com/yubikey-val/Validation_Protocol_V2.0.html)
- [YubiKey Manager](https://developers.yubico.com/yubikey-manager/)
- [Yubico API](https://www.yubico.com/products/services-software/yubicloud/)
- [YubiKey Validation Server](https://developers.yubico.com/yubikey-val/)
